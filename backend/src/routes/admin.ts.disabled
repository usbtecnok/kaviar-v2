import { Router } from 'express';
import { AdminController } from '../modules/admin/controller';
import { RideAdminController } from '../modules/admin/ride-controller';
import { DashboardController } from '../modules/admin/dashboard-controller';
import { DriverAdminController } from '../modules/admin/driver-admin-controller';
import { authenticateAdmin, requireRole } from '../middlewares/auth';
import { prisma } from '../config/database';
// import { updateCommunityGeofence, getCommunitiesWithDuplicates, archiveCommunity } from '../controllers/geofence';
// import { createCommunity } from '../controllers/community';
// import { canVerifyGeofence } from '../utils/geofence-governance';

const router = Router();
const adminController = new AdminController();
const rideController = new RideAdminController();
const dashboardController = new DashboardController();
const driverAdminController = new DriverAdminController();

// Apply authentication and authorization to all admin routes
router.use(authenticateAdmin);
router.use(requireRole(['SUPER_ADMIN', 'OPERATOR']));

// Dashboard routes
router.get('/dashboard/metrics', dashboardController.getMetrics);
router.get('/dashboard/recent-rides', dashboardController.getRecentRides);
router.get('/dashboard/drivers-overview', dashboardController.getDriversOverview);

// Drivers routes
router.get('/drivers', adminController.getDrivers);
router.get('/drivers/:id', adminController.getDriverById);
router.get('/drivers/:id/verification', driverAdminController.getVerificationStatus);
router.put('/drivers/:id/approve', adminController.approveDriver);
router.put('/drivers/:id/suspend', adminController.suspendDriver);
router.put('/drivers/:id/reactivate', adminController.reactivateDriver);
router.put('/drivers/:id/documents/:docId/verify', driverAdminController.verifyDocument);
router.put('/drivers/:id/documents/:docId/reject', driverAdminController.rejectDocument);

// Passengers routes
router.get('/passengers', adminController.getPassengers);

// Communities routes - moved to admin-management.ts

// Community geofence management
router.patch('/communities/:id/geofence', updateCommunityGeofence);
router.get('/communities/with-duplicates', getCommunitiesWithDuplicates);
router.patch('/communities/:id/archive', archiveCommunity);

// Geofence admin review endpoint
router.patch('/communities/:id/geofence-review', async (req, res) => {
  try {
    const { id } = req.params;
    const body = req.body as {
      centerLat?: number;
      centerLng?: number;
      minLat?: number;
      minLng?: number;
      maxLat?: number;
      maxLng?: number;
      isVerified?: boolean;
      reviewNotes?: string;
      selectedCanonicalId?: string; // Para casos de duplicados
    };
    
    const { centerLat, centerLng, minLat, minLng, maxLat, maxLng, isVerified, reviewNotes, selectedCanonicalId } = body;
    
    // Validar dados de entrada
    if (centerLat && (isNaN(centerLat) || centerLat < -90 || centerLat > 90)) {
      return res.status(400).json({ success: false, error: 'centerLat inválido' });
    }
    
    if (centerLng && (isNaN(centerLng) || centerLng < -180 || centerLng > 180)) {
      return res.status(400).json({ success: false, error: 'centerLng inválido' });
    }
    
    // Verificar se comunidade existe
    const community = await prisma.communities.findUnique({
      where: { id },
      include: {
        geofenceData: true
      }
    });
    
    if (!community) {
      return res.status(404).json({ success: false, error: 'Comunidade não encontrada' });
    }
    
    // Verificar se geofence existe
    const existingGeofence = await prisma.community_geofences.findUnique({
      where: { communityId: id }
    });
    
    if (!existingGeofence) {
      return res.status(404).json({ success: false, error: 'Geofence não encontrado' });
    }

    // Se tentando marcar como verificado, aplicar validações de governança
    if (isVerified === true) {
      const lat = centerLat ?? parseFloat(String(existingGeofence.centerLat));
      const lng = centerLng ?? parseFloat(String(existingGeofence.centerLng));
      
      // Verificar duplicados por nome
      const duplicates = await prisma.communities.findMany({
        where: {
          name: {
            equals: community.name,
            mode: 'insensitive'
          },
          id: { not: id }
        }
      });

      const isDuplicateName = duplicates.length > 0;
      const hasSelectedCanonical = selectedCanonicalId ? selectedCanonicalId === id : false;
      
      // Determinar tipo de geometria
      let geometryType = null;
      if (existingGeofence.geojson) {
        try {
          const geojson = JSON.parse(existingGeofence.geojson);
          geometryType = geojson.type;
        } catch (e) {
          // Ignorar erro de parsing
        }
      }

      const validationResult = canVerifyGeofence({
        isDuplicateName,
        hasSelectedCanonical,
        centerLat: lat,
        centerLng: lng,
        geometryType,
        geofenceStatus: existingGeofence.geojson ? 200 : 404
      });

      if (!validationResult.ok) {
        return res.status(400).json({ 
          success: false, 
          error: validationResult.reason,
          validationFailed: true,
          duplicates: isDuplicateName ? duplicates.map(d => ({
            id: d.id,
            name: d.name,
            centerLat: d.centerLat,
            centerLng: d.centerLng
          })) : []
        });
      }
    }
    
    // Preparar dados para atualização
    const updateData: any = {};
    
    if (centerLat !== undefined) updateData.centerLat = centerLat;
    if (centerLng !== undefined) updateData.centerLng = centerLng;
    if (minLat !== undefined) updateData.minLat = minLat;
    if (minLng !== undefined) updateData.minLng = minLng;
    if (maxLat !== undefined) updateData.maxLat = maxLat;
    if (maxLng !== undefined) updateData.maxLng = maxLng;
    if (isVerified !== undefined) updateData.isVerified = isVerified;
    if (reviewNotes !== undefined) updateData.reviewNotes = reviewNotes;
    
    // Atualizar geofence
    const updatedGeofence = await prisma.community_geofences.update({
      where: { communityId: id },
      data: updateData
    });
    
    res.json({ 
      success: true, 
      data: updatedGeofence,
      message: 'Geofence atualizado com sucesso'
    });
    
  } catch (error) {
    console.error('Erro ao atualizar geofence:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erro interno do servidor' 
    });
  }
});

// Rides routes
router.get('/rides/audit', rideController.getAuditLogs);
router.get('/rides', rideController.getRides);
router.get('/rides/:id', rideController.getRideById);
router.patch('/rides/:id/status', rideController.updateRideStatus);
router.post('/rides/:id/cancel', rideController.cancelRide);
router.post('/rides/:id/force-complete', requireRole(['SUPER_ADMIN']), rideController.forceCompleteRide);

export { router as adminRoutes };
